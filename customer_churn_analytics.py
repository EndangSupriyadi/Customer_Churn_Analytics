# -*- coding: utf-8 -*-
"""Customer_Churn_Analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1npU4zubGx2Dfqvae_wLE4VdcpNkIgc7U

**Customer_Churn_Analytics** <br>
dataset: https://www.kaggle.com/datasets/blastchar/telco-customer-churn?resource=download

Tujuan : Untuk memprediksi potensi customer melakukan churn

# **1. Data Understanding** <br>
**CustomerID**: A unique ID that identifies each customer. <br>
**Gender**: The customer’s gender: Male, Female <br>
**Senior Citizen**: Indicates if the customer is 65 or older: Yes, No <br>
**Partner** : Whether the customer has a partner or not (Yes, No) <br>
**Dependents** : Whether the customer has dependents or not (Yes, No) <br>
**Tenure** : Number of months the customer has stayed with the company <br>
**PhoneService** : Whether the customer has a phone service or not (Yes, No) <br>
**MultipleLines** : Whether the customer has multiple lines or not (Yes, No, No phone service) <br>
**InternetService** : Customer’s internet service provider (DSL, Fiber optic, No) <br>
**OnlineSecurity** : Whether the customer has online security or not (Yes, No, No internet service) <br>
**Online Backup**: Indicates if the customer subscribes to an additional online backup service provided by the company: Yes, No <br>
**Device Protection**: Indicates if the customer subscribes to an additional device protection plan for their Internet equipment provided by the company: Yes, No <br>
**Tech Support**: Indicates if the customer subscribes to an additional technical support plan from the company with reduced wait times: Yes, No <br>
**Streaming TV**: Indicates if the customer uses their Internet service to stream television programing from a third party provider: Yes, No. The company does not charge an additional fee for this service. <br>
**Streaming Movies**: Indicates if the customer uses their Internet service to stream movies from a third party provider: Yes, No. The company does not charge an additional fee for this service. <br>
**Contract**: Indicates the customer’s current contract type: Month-to-Month, One Year, Two Year. <br>
**Paperless Billing**: Indicates if the customer has chosen paperless billing: Yes, No <br>
**Payment Method**: Indicates how the customer pays their bill: Bank Withdrawal, Credit Card, Mailed Check <br>
**Monthly Charge**: Indicates the customer’s current total monthly charge for all their services from the company. <br>
**Total Charges**: Indicates the customer’s total charges, calculated to the end of the quarter specified above. <br>
**Churn**: Yes = the customer left the company this quarter. No = the customer remained with the company. Directly related to Churn Value.

# **2. Data Loading**
Menyiapkan library apa saja yang akan digunakan dan membaca dataset
"""

# Import Library
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_selection import mutual_info_classif
from imblearn.pipeline import Pipeline as ImbPipeline
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder


import joblib
import seaborn as sns
import matplotlib.pyplot as plt

# load dataset di google drive
url = '/content/drive/MyDrive/dataset/Telco-Customer-Churn.csv'
telco = pd.read_csv(url)
telco

"""**Note!**
 - Dataset terdiri dari 21 kolom dan 7043 baris dengan berbagai jenis type data.

# **3. Exploratory Data Analyst (EDA)**
mengenai lebih jauh isi dari dataset
"""

telco.info()

"""**Note!** <br>
Dataset ini ada banyak feature dengan type object nantinya akan dilakukan Encoding dan On Hot Encoding
"""

# Melihat feature target
telco['Churn'].value_counts()

# grafik value_counts
sns.countplot(x='Churn', data=telco)
plt.show()

"""**Note!** <br>
Jumlah label imbalanced ini menjadi sebuah tangtangan tapi difokuskan ke label yes untuk mendeteksi potensi kemungkinan churn
"""

# Menjadikan nilai kosong
telco= telco.replace(r'^\s*$', np.nan, regex=True)

telco.isnull().sum()

"""# **4. Data Preparation**"""

# Mengganti No Internet Service dan No Phone Service masuk kategori No
# Bersihkan "No internet service" → "No"
cols_internet = [
    'OnlineSecurity', 'OnlineBackup', 'DeviceProtection',
    'TechSupport', 'StreamingTV', 'StreamingMovies'
]

for col in cols_internet:
    telco[col] = telco[col].replace("No internet service", "No")

# Bersihkan "No phone service" → "No"
telco['MultipleLines'] = telco['MultipleLines'].replace("No phone service", "No")
telco

"""terdapat nilai kosong di TotalCharges sebanyak 11"""

# Hapus Nan di kolom TotalCharges
telco['TotalCharges'] = pd.to_numeric(telco['TotalCharges'], errors='coerce')
telco = telco.dropna(subset=['TotalCharges'])

telco.isna().sum()

telco

# Pisahkan fitur kategori & numerik (sesuai gambar yang Anda berikan)
categorical_features = [
    'customerID','gender', 'SeniorCitizen', 'Partner', 'Dependents', 'PhoneService',
    'MultipleLines', 'InternetService', 'OnlineSecurity', 'OnlineBackup',
    'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies',
    'Contract', 'PaperlessBilling', 'PaymentMethod'
]

numerical_features = ['tenure', 'MonthlyCharges', 'TotalCharges']
target = 'Churn'

from sklearn.preprocessing import OrdinalEncoder

# Label Encoding untuk Semua Fitur Kategorikal
telco_corr = telco.copy()

encoder = OrdinalEncoder(handle_unknown="use_encoded_value", unknown_value=-1)

telco_corr[categorical_features] = encoder.fit_transform(
    telco_corr[categorical_features]
)

telco_corr[target] = telco_corr[target].map({"No": 0, "Yes": 1})

telco_corr

plt.figure(figsize=(20,14))
sns.heatmap(telco_corr.corr(), annot=True, cmap="coolwarm")
plt.show()

# 1. Hitung korelasi pada data yang sudah di-encode
telco_corr = telco_corr.corr()

# 2. Ambil korelasi fitur terhadap target
corr_target = telco_corr['Churn'].abs().sort_values(ascending=False)

print("Korelasi terhadap Churn:")
print(corr_target)

# 3. Pilih fitur dengan korelasi ≥ 0.1
selected_features = corr_target[corr_target >= 0.1].index.tolist()

# 4. Hapus target jika ikut terpilih
if 'Churn' in selected_features:
    selected_features.remove('Churn')

print("\nFitur terpilih (corr >= 0.1):")
print(selected_features)

# 5. Buat dataset baru berisi fitur terpilih + target
telco_selected = telco_corr[selected_features + ['Churn']]

print("\nShape dataset baru:", telco_selected.shape)

# Fitur yang dipilih
selected_features = [
    'Contract', 'tenure', 'TotalCharges', 'MonthlyCharges', 'PaperlessBilling', 'OnlineSecurity', 'TechSupport', 'Dependents', 'SeniorCitizen', 'Partner', 'PaymentMethod', 'Churn'
]

# Dataset asli = telco
df = telco.copy()

# Tambahkan target
selected_features_with_target = selected_features

# Ambil hanya fitur terpilih + target
df_selected = df[selected_features_with_target].copy()

df_selected.head()

# Identifikasi Fitur Kategori & Numerik Setelah Seleksi
categorical_features = [
    'Contract', 'PaperlessBilling','OnlineSecurity', 'TechSupport', 'Dependents', 'SeniorCitizen', 'Partner', 'PaymentMethod', 'Churn'
]

numerical_features = ['tenure', 'MonthlyCharges', 'TotalCharges']

df_ohe = pd.get_dummies(df_selected, columns=categorical_features, drop_first=True)

df_ohe.head()

df_ohe.info()

# Split Data

X = df_ohe.drop('Churn_Yes', axis=1)
y = df_ohe['Churn_Yes']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.20, random_state=42, stratify=y
)

# Handle Data Imbalance
from imblearn.combine import SMOTETomek

smote_tomek = SMOTETomek(random_state=42)
X_train_smote, y_train_smote = smote_tomek.fit_resample(X_train, y_train)

print("Jumlah data sebelum SMOTE: ", y_train.value_counts())
print("Jumlah data setelah SMOTE: ", y_train_smote.value_counts())

# Gabungkan data train
train_df = pd.DataFrame(X_train_smote, columns=X_train.columns)
train_df['Churn_Yes'] = y_train_smote

# Gabungkan data test
test_df = pd.DataFrame(X_test, columns=X_test.columns)
test_df['Churn_Yes'] = y_test

# Pisahkan data
X_train_final = train_df.drop('Churn_Yes', axis=1)
y_train_final = train_df['Churn_Yes']

X_test_final = test_df.drop('Churn_Yes', axis=1)
y_test_final = test_df['Churn_Yes']

rf_model_1 = RandomForestClassifier(
    n_estimators=200,
    max_depth=12,
    min_samples_split=10,
    min_samples_leaf=5,
    max_features='sqrt',
    criterion='gini',
    class_weight='balanced',
    random_state=42
)

# Train Model
rf_model_1.fit(X_train_final, y_train_final)

y_pred_model_1 = rf_model_1.predict(X_test_final)

# Evaluasi
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

print("Accuracy:", accuracy_score(y_test_final, y_pred_model_1))
print("\nClassification Report:\n", classification_report(y_test_final, y_pred_model_1))
print("\nConfusion Matrix:\n", confusion_matrix(y_test_final, y_pred_model_1))

rf_model_2 = RandomForestClassifier(
    n_estimators=500,
    max_depth=None,
    min_samples_split=5,
    min_samples_leaf=2,
    max_features='sqrt',
    criterion='entropy',
    class_weight='balanced',
    random_state=42
)

rf_model_2.fit(X_train_final, y_train_final)

y_pred_model_2 = rf_model_2.predict(X_test_final)

# Evaluasi
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

print("Accuracy:", accuracy_score(y_test_final, y_pred_model_2))
print("\nClassification Report:\n", classification_report(y_test_final, y_pred_model_2))
print("\nConfusion Matrix:\n", confusion_matrix(y_test_final, y_pred_model_2))

"""# Kesimpulan Akhir
Rekomendasi Model Terbaik adalah Model 1.

Alasan Utama:

1. Prioritas Recall yang Lebih Tinggi: Model 1 memiliki Recall 0.70 (versus 0.67 pada Model 2) dan False Negative (FN) yang lebih rendah (114). Dalam pencegahan churn, tujuannya adalah meminimalkan FN, karena setiap pelanggan churn yang terlewatkan (FN) berarti kerugian pendapatan yang langsung dan signifikan bagi perusahaan.

2. Keseimbangan yang Dapat Diterima: Meskipun Model 2 memiliki Precision yang sedikit lebih tinggi (menghemat 19 kasus FP), peningkatan 8 kasus FN pada Model 2 kemungkinan besar lebih merugikan secara finansial daripada penghematan biaya insentif tersebut.

Oleh karena itu, Model 1 adalah model yang lebih baik untuk memitigasi risiko kerugian akibat churn karena lebih efektif dalam mengidentifikasi pelanggan yang benar-benar membutuhkan intervensi penyelamatan.
"""